use std::{any, borrow::Cow, fmt::Write};

use crate::modules::graphics::shader::{bind_group::MultiBindGroupT, vertex::VertexT};
use anyhow::anyhow;
use heck::ToUpperCamelCase;
use indoc::{formatdoc, indoc};
use wgpu::naga::{ScalarKind, TypeInner, VectorSize};

use super::{bind_group::BindGroupDef, vertex::VertexAttribute, ShaderStump, ShaderT};

// pub fn create_shader_skeleton<S: ShaderT>(path: &str) -> String {
//     let shader_code = ShaderCode {
//         vertex: Cow::Borrowed(indoc! {"
//             // your code here...

//         "}),
//         fragment: Cow::Borrowed(indoc! {"
//             // your code here...

//         "}),
//         other_code: Cow::Borrowed(indoc! {"
//             // You can defined additonal functions in this section.

//         "}),
//     };

// }

/// Parses a WGSL stump file into 3 sections:
/// - vertex shader inner code
/// - fragment shader inner code
/// - other functions, struct defs
///
/// The stump file is expected to have a structure like this:
/// ```wgsl
/// fn vertex() {
///     // vertex shader inner code
///     var out: VertexOutput;
///     // set output fields, these are
///     return out;
/// }
///
/// fn fragment() {
///     // fragment shader inner code
///     return vec4<f32>(1.0, 0.0, 0.0, 1.0);
/// }
///
/// // other functions, struct defs
/// ```
///
/// Notice that the function signatures are not correct wgsl.
/// That is because we auto generate those from the types provided in the ShaderT trait
/// implementation that this wgsl stump is supposed to be used with.
///
/// Bind groups will be also inserted and should not be specified manually. E.g. this is auto generated:
///
/// ```wgsl
/// @group(0) @binding(0)
/// var<uniform> camera : Camera;
/// struct Camera {
/// view_pos : vec4<f32>,
/// view_proj : mat4x4<f32>,
/// ```
///
/// Also Vertex, Instance and VertexOutput structs are autogenerated and do NOT need to be specified in the
/// wgsl stump file. E.g.
/// ```wgsl
/// struct Vertex {
///     @location(0) pos: vec3<f32>,
///     @location(1) color: vec4<f32>,
/// }
/// struct Instance {
///     @location(2) col1: vec4<f32>,
///     @location(3) col2: vec4<f32>,
///     @location(4) col3: vec4<f32>,
///     @location(5) translation: vec4<f32>,
/// }
/// struct VertexOutput {
///     @builtin(position) clip_position: vec4<f32>,
///     @location(0) color: vec4<f32>,
/// }
/// ```
///
/// The function signatures are also auto generated.
///
/// The vertex shader can have any of the inputs here:
/// - Inputs: `vertex_index: u32`, `instance_index: u32`, `vertex: Vertex`, `instance: Instance`
/// - Output: VertexOutput
///
/// The fragment shader can have these inputs:
/// - Inputs: `in: VertexOutput`,  `position: vec4<f32>`, `front_facing: bool`, `frag_depth: f32`, `sample_index: u32`, `sample_mask: u32`,
/// - Output: vec4<f32> (The fragment color)
///
pub fn read_from_wgsl_stump(stump: &str) -> anyhow::Result<ShaderStump> {
    // Super naive, make better later.

    // let mut vertex_shader_chars: Vec<char> = vec![];
    // let mut fragment_shader_chars: Vec<char> = vec![];
    let mut other_code: String = String::new();
    let fnvert_idx = stump
        .find("fn vertex(")
        .ok_or(anyhow!("fn vertex( not found in wgsl stump"))?;

    // code before
    other_code.push_str(&stump[..fnvert_idx]);

    let (vertex_shader_inner, rest) = next_curly_bracket_region(&stump[fnvert_idx..])?;

    let fnfrag_idx = rest.find("fn fragment(").ok_or(anyhow!(
        "fn fragment( not found in wgsl stump (has to come after fn vertex(..) )"
    ))?;

    // code between vertex and fragment shader
    other_code.push_str(&rest[..fnfrag_idx]);

    let (fragment_shader_inner, rest) = next_curly_bracket_region(&rest[fnfrag_idx..])?;

    // code after fragment shader
    other_code.push_str(&rest);

    Ok(ShaderStump {
        vertex: vertex_shader_inner.into(),
        fragment: fragment_shader_inner.into(),
        other_code: other_code.into(),
    })
}

/// Looks for the next bracket scope in a string, returning all characters in it.
/// Super naive..., returns rest of the input str after the bracket region
fn next_curly_bracket_region(input: &str) -> anyhow::Result<(String, &str)> {
    let mut res: String = String::new();
    let mut level: i32 = 0;
    let last_bracket_index: usize;
    let mut iter = input.char_indices();
    loop {
        let (i, c) = iter
            .next()
            .ok_or_else(|| anyhow!("Curly Bracket region is not fully enclosed"))?;
        match (level, c) {
            (0, '{') => {
                level += 1;
            }
            (0, _) => {
                // nothing, skip over these chars
            }
            (1, '}') => {
                // region is over:
                last_bracket_index = i;
                break;
            }
            (_, '{') => {
                level += 1;
                res.push(c);
            }
            (_, '}') => {
                level -= 1;
                res.push(c);
            }
            (_, _) => {
                res.push(c);
            }
        }
    }

    return Ok((res, &input[(last_bracket_index + 1)..]));
}

pub fn generate_wgsl<S: ShaderT>(stump: &ShaderStump) -> String {
    let vertex_inner_code = &stump.vertex;
    let fragment_inner_code = &stump.fragment;
    let other_code = &stump.other_code;

    let bind_groups = bind_groups_to_wgsl(<S::BindGroups as MultiBindGroupT>::BIND_GROUP_DEFS);

    let (vertex_output_struct_def, vertex_struct_def, instance_struct_def) =
        vertex_instance_output_struct_defs::<S>();

    let vertex_function_args: String = {
        let mut args: Vec<String> = vec![];

        let builtins = find_usage_of_builtin_inputs(vertex_inner_code, WGPU_VERTEX_BUILTIN_INPUTS);
        for (name, ty) in builtins {
            args.push(format!("@builtin({name}) {name}: {ty}"));
        }
        if vertex_struct_def.is_some() {
            args.push("vertex: Vertex".into());
        }
        if instance_struct_def.is_some() {
            args.push("instance: Instance".into());
        }

        args.join(", ")
    };

    let fragment_function_args: String = {
        let mut args: Vec<String> = vec![];

        let builtins =
            find_usage_of_builtin_inputs(fragment_inner_code, WGPU_FRAGMENT_BUILTIN_INPUTS);
        for (name, ty) in builtins {
            args.push(format!("@builtin({name}) {name}: {ty}"));
        }
        args.push("in: VertexOutput".into());
        args.join(", ")
    };

    let vertex_struct_def = vertex_struct_def.unwrap_or_default();
    let instance_struct_def = instance_struct_def.unwrap_or_default();

    formatdoc! {"
        {bind_groups}

        {vertex_output_struct_def}

        {vertex_struct_def}

        {instance_struct_def}

        @vertex 
        fn vs_main({vertex_function_args}) -> VertexOutput {{
            {vertex_inner_code}
        }}

        @fragment 
        fn fs_main({fragment_function_args}) -> @location(0) vec4<f32>  {{
            {fragment_inner_code}
        }}
    
        {other_code}
    "}
}

/// generates struct_defs for (VertexOutput, Vertex, Instance)
fn vertex_instance_output_struct_defs<S: ShaderT>() -> (String, Option<String>, Option<String>) {
    let vertex_output_struct_def = vertex_attributes_to_wgsl_struct(
        <S::VertexOutput as VertexT>::ATTRIBUTES,
        0,
        "VertexOutput",
    );

    let vertex_attributes = <S::Vertex as VertexT>::ATTRIBUTES;
    let vertex_struct_def: Option<String> = if vertex_attributes.is_empty() {
        None
    } else {
        Some(vertex_attributes_to_wgsl_struct(
            vertex_attributes,
            0,
            "Vertex",
        ))
    };

    let instance_attributes = <S::Instance as VertexT>::ATTRIBUTES;
    let instance_struct_def = if instance_attributes.is_empty() {
        None
    } else {
        Some(vertex_attributes_to_wgsl_struct(
            instance_attributes,
            vertex_attributes.len(),
            "Instance",
        ))
    };

    (
        vertex_output_struct_def,
        vertex_struct_def,
        instance_struct_def,
    )
}

fn vertex_attributes_to_wgsl_struct(
    vertex_attributes: &[VertexAttribute],
    location_offset: usize,
    struct_name: &str,
) -> String {
    let mut s: String = format!("struct {struct_name} {{\n");
    if struct_name == "VertexOutput" {
        _ = writeln!(s, "    @builtin(position) clip_position: vec4<f32>,");
    }

    for (i, attr) in vertex_attributes.iter().enumerate() {
        let i = i + location_offset;
        let attr_name = attr.ident;
        let attr_type = vertex_format_to_wgsl(attr.format);
        _ = writeln!(s, "    @location({i}) {attr_name}: {attr_type},");
    }

    s.push_str("}\n");
    s
}

fn bind_groups_to_wgsl(bind_groups: &[&BindGroupDef]) -> String {
    let mut s: String = String::new();

    for (i, def) in bind_groups.iter().enumerate() {
        for (j, entry) in def.entries.iter().enumerate() {
            if matches!(entry.ty, wgpu::BindingType::Buffer { ty, .. })
                && entry.struct_fields.is_none()
            {
                panic!("For Buffer bindings, you need to define struct_fields in the BindGroupDef!")
            }
            let entry_name = entry.name;
            let entry_name_upper = entry_name.to_upper_camel_case();
            let (prefix, ty) = match entry.ty {
                wgpu::BindingType::Buffer {
                    ty,
                    has_dynamic_offset,
                    min_binding_size,
                } => match ty {
                    wgpu::BufferBindingType::Uniform => ("var<uniform>", entry_name_upper.as_str()),
                    wgpu::BufferBindingType::Storage { read_only } => {
                        panic!(
                            "todo!(Storage Buffers not yet implemented as a binding group definition)"
                        )
                    }
                },
                wgpu::BindingType::Sampler(_) => ("var", "sampler"),
                wgpu::BindingType::Texture {
                    sample_type,
                    view_dimension,
                    multisampled,
                } => {
                    let sample_ty = match sample_type {
                        wgpu::TextureSampleType::Float { filterable } => "texture_2d<f32>",
                        wgpu::TextureSampleType::Depth => "texture_depth_2d",
                        wgpu::TextureSampleType::Sint => "texture_2d<i32>",
                        wgpu::TextureSampleType::Uint => "texture_2d<u32>",
                    };
                    ("var", sample_ty)
                }
                wgpu::BindingType::StorageTexture {
                    access,
                    format,
                    view_dimension,
                } => panic!(
                    "todo!(StorageTexture is not yet implemented as a binding group definition)"
                ),
            };

            _ = writeln!(s, "@group({i}) @binding({j})");
            _ = writeln!(s, "{prefix} {entry_name} : {ty};\n");

            // eg. something like this
            //
            // @group(0) @binding(0)
            // var<uniform> camera: Camera;
            // @group(1) @binding(0)
            // var t_diffuse: texture_2d<f32>;
            // @group(1) @binding(1)
            // var s_diffuse: sampler;

            // add struct definition for uniforms:

            if let Some(struct_fields) = entry.struct_fields {
                // eg. something like:

                // struct Camera {
                //     view_pos: vec4<f32>,
                //     view_proj: mat4x4<f32>,
                // }

                _ = writeln!(s, "struct {ty} {{");
                for (field_name, field_ty) in struct_fields {
                    let field_ty = type_inner_to_wgsl(field_ty);
                    _ = writeln!(s, "    {field_name} : {field_ty},");
                }

                _ = writeln!(s, "}}\n");
            }
        }
    }

    s
}

pub fn find_usage_of_builtin_inputs(
    code: &str,
    builtins: &'static [(&'static str, &'static str)],
) -> Vec<(&'static str, &'static str)> {
    let mut found: Vec<(&'static str, &'static str)> = vec![];
    for (name, ty) in builtins {
        // super naive, make better later...
        if code.contains(name) {
            found.push((*name, *ty));
        }
    }
    found
}

/// See https://www.w3.org/TR/WGSL/#built-in-values
const WGPU_VERTEX_BUILTIN_INPUTS: &[(&str, &str)] =
    &[("vertex_index", "u32"), ("instance_index", "u32")];

/// See https://www.w3.org/TR/WGSL/#built-in-values
const WGPU_FRAGMENT_BUILTIN_INPUTS: &[(&str, &str)] = &[
    ("position", "vec4<f32>"),
    ("front_facing", "bool"),
    ("frag_depth", "f32"),
    ("sample_index", "u32"),
    ("sample_mask", "u32"),
];

pub fn type_inner_to_wgsl(type_inner: &TypeInner) -> String {
    match type_inner {
        TypeInner::Scalar { kind, width } => scalar_to_wgsl(kind).into(),
        TypeInner::Vector { size, kind, width } => {
            format!("vec{}<{}>", *size as u32, scalar_to_wgsl(kind))
        }
        TypeInner::Matrix {
            columns,
            rows,
            width,
        } => format!("mat{}x{}<f32>", *columns as u32, *rows as u32,),
        _ => panic!("todo!() type {type_inner:?} not supported as field of a uniform, yet."),
    }
}

pub fn scalar_to_wgsl(scalar: &ScalarKind) -> &'static str {
    match scalar {
        ScalarKind::Sint => "i32",
        ScalarKind::Uint => "u32",
        ScalarKind::Float => "f32",
        ScalarKind::Bool => "bool", // ???
    }
}

pub const fn vertex_format_to_wgsl(vertex_format: wgpu::VertexFormat) -> &'static str {
    const u32: &str = "u32";
    const vec2u32: &str = "vec2<u32>";
    const vec3u32: &str = "vec3<u32>";
    const vec4u32: &str = "vec4<u32>";

    const i32: &str = "i32";
    const vec2i32: &str = "vec2<i32>";
    const vec3i32: &str = "vec3<i32>";
    const vec4i32: &str = "vec4<i32>";

    const f32: &str = "f32";
    const vec2f32: &str = "vec2<f32>";
    const vec3f32: &str = "vec3<f32>";
    const vec4f32: &str = "vec4<f32>";

    match vertex_format {
        wgpu::VertexFormat::Uint8x2 => vec2u32,
        wgpu::VertexFormat::Uint8x4 => vec4u32,
        wgpu::VertexFormat::Sint8x2 => vec2i32,
        wgpu::VertexFormat::Sint8x4 => vec4i32,
        wgpu::VertexFormat::Unorm8x2 => vec2f32,
        wgpu::VertexFormat::Unorm8x4 => vec4f32,
        wgpu::VertexFormat::Snorm8x2 => vec2f32,
        wgpu::VertexFormat::Snorm8x4 => vec4f32,
        wgpu::VertexFormat::Uint16x2 => vec2u32,
        wgpu::VertexFormat::Uint16x4 => vec4u32,
        wgpu::VertexFormat::Sint16x2 => vec2i32,
        wgpu::VertexFormat::Sint16x4 => vec4i32,
        wgpu::VertexFormat::Unorm16x2 => vec2f32,
        wgpu::VertexFormat::Unorm16x4 => vec4f32,
        wgpu::VertexFormat::Snorm16x2 => vec2f32,
        wgpu::VertexFormat::Snorm16x4 => vec4f32,
        wgpu::VertexFormat::Float16x2 => vec2f32,
        wgpu::VertexFormat::Float16x4 => vec4f32,
        wgpu::VertexFormat::Float32 => f32,
        wgpu::VertexFormat::Float32x2 => vec2f32,
        wgpu::VertexFormat::Float32x3 => vec3f32,
        wgpu::VertexFormat::Float32x4 => vec4f32,
        wgpu::VertexFormat::Uint32 => u32,
        wgpu::VertexFormat::Uint32x2 => vec2u32,
        wgpu::VertexFormat::Uint32x3 => vec3u32,
        wgpu::VertexFormat::Uint32x4 => vec4u32,
        wgpu::VertexFormat::Sint32 => i32,
        wgpu::VertexFormat::Sint32x2 => vec2i32,
        wgpu::VertexFormat::Sint32x3 => vec3i32,
        wgpu::VertexFormat::Sint32x4 => vec4i32,
        wgpu::VertexFormat::Float64 => f32,
        wgpu::VertexFormat::Float64x2 => vec2f32,
        wgpu::VertexFormat::Float64x3 => vec3f32,
        wgpu::VertexFormat::Float64x4 => vec4f32,
    }
}

// #[deprecated]
// pub fn generate_md_shader_skeleton<S: ShaderT>(path: &str) {
//     let bind_groups = bind_groups_to_wgsl(<S::BindGroups as MultiBindGroupT>::BIND_GROUP_DEFS);

//     let (vertex_output_struct_def, vertex_struct_def, instance_struct_def) =
//         vertex_instance_output_struct_defs::<S>();

//     let vertex_function_args: String = {
//         let mut args: Vec<String> = vec![];
//         for (name, ty) in WGPU_VERTEX_BUILTIN_INPUTS {
//             args.push(format!("`{name}: {ty}`"));
//         }
//         if vertex_struct_def.is_some() {
//             args.push("`vertex: Vertex`".into());
//         }
//         if instance_struct_def.is_some() {
//             args.push("`instance: Instance`".into());
//         }

//         args.join(", ")
//     };

//     let fragment_function_args: String = {
//         let mut args: Vec<String> = vec![];
//         for (name, ty) in WGPU_FRAGMENT_BUILTIN_INPUTS {
//             args.push(format!("`{name}: {ty}`"));
//         }
//         args.push("`in: VertexOutput`".into());
//         args.join(", ")
//     };

//     let vertex_struct_def = vertex_struct_def.unwrap_or("// No Vertex Struct".into());
//     let instance_struct_def = instance_struct_def.unwrap_or("// No Instance Struct".into());

//     let shader_name = std::any::type_name::<S>();

//     let output = formatdoc! {"
//         # {shader_name}
//         Shader Source File. Code in this segment annotated with `rs,wgsl`, `rs,wgsl,vertex` or `rs,wgsl,fragment` will be assembled into a the {shader_name} Shader.

//         ## Bind Groups
//         ```rs,wgsl,ignore
//         {bind_groups}
//         ```

//         ## Vertex, Instance and VertexOutput
//         ```rs,wgsl,ignore
//         {vertex_struct_def}
//         {instance_struct_def}
//         {vertex_output_struct_def}
//         ```

//         ## Vertex Shader
//         - Inputs: {vertex_function_args}
//         - Output: VertexOutput

//         ```rs,wgsl,vertex
//         // Code here will be inserted into the vertex shader.

//         var output: VertexOutput;
//         // set output..
//         return output;
//         ```

//         ## Fragment Shader
//         - Inputs: {fragment_function_args}
//         - Output: vec4<f32> (The fragment color)

//         ```rs,wgsl,fragment
//         // Code here will be inserted into the fragment shader.

//         return vec4(1.0,0.0,0.0,1.0);
//         ```

//         ## Other Code
//         ```rs,wgsl
//         // Here you can define other structs functions that the parse will pick up on.
//         ```
//     "};

//     std::fs::write(path, output).expect("Could not write to file.");
// }
